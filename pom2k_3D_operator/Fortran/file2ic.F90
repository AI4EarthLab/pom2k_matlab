      subroutine file2ic
      use dm
      use dm_op
      use constants
      use input
      use gird
      use dm_type
C **********************************************************************
C *                                                                    *
C * FUNCTION    :  Sets up my own problem.                             *
C *                                                                    *
C * This example read IC from IC.dat file, generated by GRID.f in      *
C * GRID-DATA directory. Only minimal number of fields are read,       *
C * while others are calculated here.                                  *
C *                                                                    *
C **********************************************************************
C
      implicit none
      real(kind=8):: rad,re,dlat,dlon
      integer:: i,j,k
      integer,intent(out) :: ierr
      real(kind=8), allocatable :: z1(:),zz1(:),dz1(:),dzz1(:),
     $                             ele1(:),elw1(:),uabe1(:),uabw1(:),
     $                             els1(:),eln1(:),uabs1(:),uabn1(:)
      real(kind=8), allocatable :: east_e1(:,:), north_e1(:,:),h1(:,:),wusurf1(:,:),
     $                             wvsurf1(:,:),tsurf1(:,:), ssurf1(:,:),
     $                             ubw1(:,:),ube1(:,:),tbw1(:,:),sbw1(:,:),tbe1(:,:),sbe1(:,:),
     $                             vbs1(:,:),vbn1(:,:),tbs1(:,:),sbs1(:,:),tbn1(:,:),sbn1(:,:),
     $                             cor1(:,:),aam2d1(:,:),elb1(:,:),etb1(:,:),dt1(:,:),dx1(:,:),
     $                             dy1(:,:),east_c1(:,:),north_c1(:,:),east_u1(:,:),north_u1(:,:),
     $                             east_v1(:,:),north_v1(:,:),rot1(:,:)
      real(kind=8), allocatable :: t1(:,:,:), s1(:,:,:),rmean1(:,:,:),tclim1(:,:,:), sclim1(:,:,:),
     $                             tb1(:,:,:),sb1(:,:,:),ub1(:,:,:),vb1(:,:,:) 
      character*5 field
      rad=0.01745329
      re=6371.E3
      allocate(z1(kb),zz1(kb),dz1(kb),dzz1(kb),
     $         ele1(jm),elw1(jm),uabe1(jm),uabw1(jm),
     $         els1(im),eln1(im),uabs1(im),uabn1(im))
      allocate(east_e1(im,jm),north_e1(im,jm),h1(im,jm),wusurf1(im,jm),wvsurf1(im,jm),
     $         tsurf1(im,jm),ssurf1(im,jm),
     $         ubw1(jm,kb),ube1(jm,kb),tbw1(jm,kb),sbw1(jm,kb),tbe1(jm,kb),sbe1(jm,kb),
     $         vbs1(im,kb),vbn1(im,kb),tbs1(im,kb),sbs1(im,kb),tbn1(im,kb),sbn1(im,kb),
     $         cor1(im,jm),aam2d1(im,jm),elb1(im,jm),etb1(im,jm),dt1(im,jm),dx1(im,jm),
     $         dy1(im,jm),east_c1(im,jm),north_c1(im,jm),east_u1(im,jm),north_u1(im,jm),
     $         east_v1(im,jm),north_v1(im,jm),rot1(im,jm))
 
      allocate(t1(im,jm,kb),s1(im,jm,kb),rmean1(im,jm,kb),tclim1(im,jm,kb),sclim1(im,jm,kb),
     $         tb1(im,jm,kb),sb1(im,jm,kb),ub1(im,jm,kb),vb1(im,jm,kb) )
C
      write(6,'(/,'' Read grid and initial conditions '',/)')
C
C--- 1D ---
      read(40,'(a5)') field
      write(6,'(a5)') field
       read(40,'(8E12.5)') z1
      read(40,'(a5)') field
      write(6,'(a5)') field
       read(40,'(8E12.5)') zz1
      read(40,'(a5)') field
      write(6,'(a5)') field
       read(40,'(8E12.5)') dz1
      read(40,'(a5)') field
      write(6,'(a5)') field
       read(40,'(8E12.5)') dzz1
C--- 2D ---
      read(40,'(a5)') field
      write(6,'(a5)') field
       read(40,'(8E12.5)') east_e1
      read(40,'(a5)') field
      write(6,'(a5)') field
       read(40,'(8E12.5)') north_e1
      read(40,'(a5)') field
      write(6,'(a5)') field
       read(40,'(8E12.5)') h1
C--- 3D ---
      read(40,'(a5)') field
      write(6,'(a5)') field
       read(40,'(8E12.5)') t1
      read(40,'(a5)') field
      write(6,'(a5)') field
       read(40,'(8E12.5)') s1
      read(40,'(a5)') field
      write(6,'(a5)') field
       read(40,'(8E12.5)') rmean1
C--- Constant wind stress read here
C (for time dep. read in loop 9000 & interpolate in time)
      read(40,'(a5)') field
      write(6,'(a5)') field
       read(40,'(8E12.5)') wusurf1
      read(40,'(a5)') field
      write(6,'(a5)') field
       read(40,'(8E12.5)') wvsurf1

	   
C
C --- calc. surface & lateral BC from climatology
C
        do j=1,jm
          do i=1,im
             tsurf1(i,j)=t1(i,j,1)
             ssurf1(i,j)=s1(i,j,1)
            do k=1,kb
              tclim1(i,j,k)=t1(i,j,k)
              sclim1(i,j,k)=s1(i,j,k)
            end do
          end do
        end do
C
C                    --- EAST & WEST BCs ---
        do j=1,jm
              ele1(j)=0.
              elw1(j)=0.
C --- other vel. BCs (fixed in time) can be specified here
              uabe1(j)=0.
              uabw1(j)=0.
            do k=1,kb
              ubw1(j,k)=0.
              ube1(j,k)=0.
              tbw1(j,k)=tclim1(1,j,k)
              sbw1(j,k)=sclim1(1,j,k)
              tbe1(j,k)=tclim1(im,j,k)
              sbe1(j,k)=sclim1(im,j,k)
            end do
        end do
C                    --- NORTH & SOUTH BCs ---
        do i=1,im
              els1(i)=0.
              eln1(i)=0.
              vabs1(i)=0.
              vabn1(i)=0.
            do k=1,kb
              vbs1(i,k)=0.
              vbn1(i,k)=0.
              tbs1(i,k)=tclim1(i,1,k)
              sbs1(i,k)=sclim1(i,1,k)
              tbn1(i,k)=tclim1(i,jm,k)
              sbn1(i,k)=sclim1(i,jm,k)
            end do
        end do
C
C     Set initial conditions:
C
      do k=1,kb
        do j=1,jm
          do i=1,im
            tb1(i,j,k)=t1(i,j,k)
            sb1(i,j,k)=s1(i,j,k)
            ub1(i,j,k)=0.
            vb1(i,j,k)=0.
          end do
        end do
      end do
C
C      call dens(sb1,tb1,rho1)
C
C --- calc. Curiolis Parameter
C
        do j=1,jm
          do i=1,im
            cor1(i,j)=2.*7.29E-5*sin(north_e1(i,j)*rad)
            aam2d1(i,j)=aam1(i,j,1)
            elb1(i,j)=0.
            etb1(i,j)=0.
            dt1(i,j)=h1(i,j)
          end do
        end do
C
        do j=1,jm
          do i=2,im-1
            dx1(i,j)=0.5*rad*re*sqrt(((east_e1(i+1,j)-east_e1(i-1,j))
     1 *cos(north_e1(i,j)*rad))**2+(north_e1(i+1,j)-north_e1(i-1,j))**2)
          end do
            dx1(1,j)=dx1(2,j)
            dx1(im,j)=dx1(im-1,j)
        end do
C
        do i=1,im
          do j=2,jm-1
            dy1(i,j)=0.5*rad*re*sqrt(((east_e1(i,j+1)-east_e1(i,j-1))
     1 *cos(north_e1(i,j)*rad))**2+(north_e1(i,j+1)-north_e1(i,j-1))**2)
          end do
            dy1(i,1)=dy1(i,2)
            dy1(i,jm)=dy1(i,jm-1)
        end do
C
C     Calculate areas and masks:
C
C      call areas_masks
C
C
C --- the following grids are needed only for netcdf plotting
C
C     Corner of cell points:
C
      do j=2,jm
        do i=2,im
          east_c1(i,j)=(east_e1(i,j)+east_e1(i-1,j)
     $                  +east_e1(i,j-1)+east_e1(i-1,j-1))/4.0
          north_c1(i,j)=(north_e1(i,j)+north_e1(i-1,j)
     $                   +north_e1(i,j-1)+north_e1(i-1,j-1))/4.0
        end do
      end do
C
C
C     Extrapolate ends (approx.):
C
      do i=2,im
        east_c1(i,1)=2.*east_c1(i,2)-east_c1(i,3)
        north_c1(i,1)=2.*north_c1(i,2)-north_c1(i,3)
      end do
        east_c1(1,1)=2.*east_c1(2,1)-east_c1(3,1)
C
      do j=2,jm
        east_c1(1,j)=2.*east_c1(2,j)-east_c1(3,j)
        north_c1(1,j)=2.*north_c1(2,j)-north_c1(3,j)
      end do
        north_c1(1,1)=2.*north_c1(1,2)-north_c1(1,3)
C
C     u-points:
C
      do j=1,jm-1
        do i=1,im
          east_u1(i,j)=(east_c1(i,j)+east_c1(i,j+1))/2.0
          north_u1(i,j)=(north_c1(i,j)+north_c1(i,j+1))/2.0
        end do
      end do
C
C     Extrapolate ends:
C
      do i=1,im
        east_u1(i,jm)=(east_c1(i,jm)*3.0-east_c1(i,jm-1))/2.0
        north_u1(i,jm)=(north_c1(i,jm)*3.0-north_c1(i,jm-1))/2.0
      end do
C
C     v-points:
C
      do j=1,jm
        do i=1,im-1
          east_v1(i,j)=(east_c1(i,j)+east_c1(i+1,j))/2.0
          north_v1(i,j)=(north_c1(i,j)+north_c1(i+1,j))/2.0
        end do
      end do
C
C     Extrapolate ends:
C
      do j=1,jm
        east_v1(im,j)=(east_c1(im,j)*3.0-east_c1(im-1,j))/2.0
        north_v1(im,j)=(north_c1(im,j)*3.0-north_c1(im-1,j))/2.0
      end do
C
C     rot is the angle (radians, anticlockwise) of the i-axis relative
C     to east, averaged to a cell centre: (only needed for CDF plotting)
C
      do j=1,jm
        do i=1,im-1
          rot1(i,j)=0.
          dlat=north_e1(i+1,j)-north_e1(i,j)
          dlon= east_e1(i+1,j)- east_e1(i,j)
           if(dlon.ne.0.) rot1(i,j)=atan(dlat/dlon)
        end do
       rot1(im,j)=rot1(im-1,j)
      end do
C
C     Set lateral boundary conditions, for use in subroutine bcond
C     set all=0 for closed BCs.
C     Values=0 for vel BC only, =1 is combination of vel+elev.
      rfe=0.0
      rfw=0.0
      rfn=0.0
      rfs=0.0
C
      z  = dm_zeros(1, 1, kb)
      zz = dm_zeros(1, 1, kb)
      dz = dm_zeros(1, 1, kb)
      dzz= dm_zeros(1, 1, kb)
      call dm_setvalues(z,   (/0/), (/0/), (/(i, i=0,kb-1)/), z1,   ierr)
      call dm_setvalues(zz,  (/0/), (/0/), (/(i, i=0,kb-1)/), zz1,  ierr)
      call dm_setvalues(dz,  (/0/), (/0/), (/(i, i=0,kb-1)/), dz1,  ierr)
      call dm_setvalues(dzz, (/0/), (/0/), (/(i, i=0,kb-1)/), dzz1, ierr)
      call dm_setvalues(east_e, (/i,i=0,im-1/), (/j,j=0,jm-1/), (/(0)/), east_e1, ierr)
      call dm_setvalues(north_e, (/i,i=0,im-1/), (/j,j=0,jm-1/), (/(0)/), north_e1, ierr)
      call dm_setvalues(h, (/i,i=0,im-1/), (/j,j=0,jm-1/), (/(0)/), h1, ierr)
      call dm_setvalues(t, (/i,i=0,im-1/), (/j,j=0,jm-1/), (/(k,k=0,kb-1)/), t1, ierr)	  
      call dm_setvalues(s, (/i,i=0,im-1/), (/j,j=0,jm-1/), (/(k,k=0,kb-1)/), s1, ierr)
      call dm_setvalues(rmean, (/i,i=0,im-1/), (/j,j=0,jm-1/), (/(k,k=0,kb-1)/), rmean1, ierr)
  
      call dm_setvalues(wusurf, (/i,i=0,im-1/), (/j,j=0,jm-1/), (/(0)/), wusurf1, ierr)
      call dm_setvalues(wvsurf, (/i,i=0,im-1/), (/j,j=0,jm-1/), (/(0)/), wvsurf1, ierr)
      call dm_setvalues(tsurf, (/i,i=0,im-1/), (/j,j=0,jm-1/), (/(0)/), tsurf1, ierr)	  
      call dm_setvalues(ssurf, (/i,i=0,im-1/), (/j,j=0,jm-1/), (/(0)/), ssurf1, ierr)
      call dm_setvalues(tclim, (/i,i=0,im-1/), (/j,j=0,jm-1/), (/(k,k=0,kb-1)/), tclim1, ierr)	  
      call dm_setvalues(sclim, (/i,i=0,im-1/), (/j,j=0,jm-1/), (/(k,k=0,kb-1)/), sclim1, ierr)	  
      call dm_setvalues(ele, (/0/), (/j,j=0,jm-1/), (/(0)/), ele1, ierr)
      call dm_setvalues(elw, (/0/), (/j,j=0,jm-1/), (/(0)/), elw1, ierr)	  
      call dm_setvalues(uabe, (/0/), (/j,j=0,jm-1/), (/(0)/), uabe1, ierr)
      call dm_setvalues(uabw, (/0/), (/j,j=0,jm-1/), (/(0)/), uabw1, ierr)

      call dm_setvalues(ubw, (/j,j=0,jm-1/), (/k,k=0,kb-1/), (/(0)/), ubw1, ierr)
      call dm_setvalues(ube, (/j,j=0,jm-1/), (/k,k=0,kb-1/), (/(0)/), ube1, ierr)	  
      call dm_setvalues(tbw, (/j,j=0,jm-1/), (/k,k=0,kb-1/), (/(0)/), tbw1, ierr)
      call dm_setvalues(sbw, (/j,j=0,jm-1/), (/k,k=0,kb-1/), (/(0)/), sbw1, ierr)
      call dm_setvalues(tbe, (/j,j=0,jm-1/), (/k,k=0,kb-1/), (/(0)/), tbe1, ierr)
      call dm_setvalues(sbe, (/j,j=0,jm-1/), (/k,k=0,kb-1/), (/(0)/), sbe1, ierr)
      call dm_setvalues(els, (/0/), (/i,i=0,im-1/),(/(0)/), els1, ierr)	  
      call dm_setvalues(eln, (/0/), (/i,i=0,im-1/),(/(0)/), eln1, ierr)		  
      call dm_setvalues(uabs, (/0/), (/i,i=0,im-1/),(/(0)/), uabs1, ierr)	  
      call dm_setvalues(uabn, (/0/), (/i,i=0,im-1/),(/(0)/), uabn1, ierr)

      call dm_setvalues(vbs, (/i,i=0,im-1/), (/k,k=0,kb-1/), (/(0)/), vbs1, ierr)
      call dm_setvalues(vbn, (/i,i=0,im-1/), (/k,k=0,kb-1/), (/(0)/), vbn1, ierr)	  
      call dm_setvalues(tbs, (/i,i=0,im-1/), (/k,k=0,kb-1/), (/(0)/), tbs1, ierr)
      call dm_setvalues(sbs, (/i,i=0,im-1/), (/k,k=0,kb-1/), (/(0)/), sbs1, ierr)
      call dm_setvalues(tbn, (/i,i=0,im-1/), (/k,k=0,kb-1/), (/(0)/), tbn1, ierr)
      call dm_setvalues(sbn, (/i,i=0,im-1/), (/k,k=0,kb-1/), (/(0)/), sbn1, ierr)
      call dm_setvalues(tb, (/i,i=0,im-1/), (/j,j=0,jm-1/), (/(k,k=0,kb-1)/), tb1, ierr)	  
      call dm_setvalues(sb, (/i,i=0,im-1/), (/j,j=0,jm-1/), (/(k,k=0,kb-1)/), sb1, ierr)
      call dm_setvalues(ub, (/i,i=0,im-1/), (/j,j=0,jm-1/), (/(k,k=0,kb-1)/), ub1, ierr)	  
      call dm_setvalues(vb, (/i,i=0,im-1/), (/j,j=0,jm-1/), (/(k,k=0,kb-1)/), vb1, ierr)

      call dm_setvalues(cor, (/i,i=0,im-1/), (/j,j=0,jm-1/), (/(0)/),     cor1, ierr)
      call dm_setvalues(aam2d, (/i,i=0,im-1/), (/j,j=0,jm-1/), (/(0)/), aam2d1, ierr)
      call dm_setvalues(elb, (/i,i=0,im-1/), (/j,j=0,jm-1/), (/(0)/), elb1, ierr)	  
      call dm_setvalues(etb, (/i,i=0,im-1/), (/j,j=0,jm-1/), (/(0)/), etb1, ierr)	  
      call dm_setvalues(dt, (/i,i=0,im-1/), (/j,j=0,jm-1/), (/(0)/), dt1, ierr)
      call dm_setvalues(dx, (/i,i=0,im-1/), (/j,j=0,jm-1/), (/(0)/), dx1, ierr)
      call dm_setvalues(dy, (/i,i=0,im-1/), (/j,j=0,jm-1/), (/(0)/), dy1, ierr)	  
      call dm_setvalues(east_c, (/i,i=0,im-1/), (/j,j=0,jm-1/), (/(0)/),   east_c1, ierr)	  
      call dm_setvalues(north_c, (/i,i=0,im-1/), (/j,j=0,jm-1/), (/(0)/), north_c1, ierr)	  
      call dm_setvalues(east_u, (/i,i=0,im-1/), (/j,j=0,jm-1/), (/(0)/),   east_u1, ierr)		  
   
      call dm_setvalues(north_u, (/i,i=0,im-1/), (/j,j=0,jm-1/), (/(0)/), north_u1, ierr)	  
      call dm_setvalues(east_v, (/i,i=0,im-1/), (/j,j=0,jm-1/), (/(0)/),  east_v1, ierr)	
      call dm_setvalues(north_v, (/i,i=0,im-1/), (/j,j=0,jm-1/), (/(0)/), north_v1, ierr)
      call dm_setvalues(rot, (/i,i=0,im-1/), (/j,j=0,jm-1/), (/(0)/),     rot1, ierr)
       
      z_3d   =dm_rep(z,   im, jm, 1)
      zz_3d  =dm_rep(zz,  im, jm, 1)
      dz_3d  =dm_rep(dz,  im, jm, 1)
      dzz_3d =dm_rep(dzz, im, jm, 1)
      dx_3d  =dm_rep(dx,  1,  1, kb)
      dy_3d  =dm_rep(dy,  1,  1, kb)
      cor_3d =dm_rep(cor, 1,  1, kb)
      dt_3d  =dm_rep(dt,  1,  1, kb)
      h_3d   =dm_rep(h,   1,  1, kb)	  

      call areas_masks	  
  
      art_3d =dm_rep(art, 1,  1, kb)
      aru_3d =dm_rep(aru, 1,  1, kb)
      arv_3d =dm_rep(arv, 1,  1, kb)
      dum_3d =dm_rep(dum, 1,  1, kb)
      dvm_3d =dm_rep(dvm, 1,  1, kb)
      fsm_3d =dm_rep(fsm, 1,  1, kb)
      
      deallocate(z1,zz1,dz1,dzz1,ele1,elw1,uabe1,uabw1,els1,eln1,uabs1,uabn1,
     $           east_e1, north_e1,h1,wusurf1,wvsurf1,tsurf1, ssurf1,
     $           ubw1,ube1,tbw1,sbw1,tbe1,sbe1,vbs1,vbn1,tbs1,sbs1,
     $           tbn1,sbn1,cor1,aam2d1,elb1,etb1,dt1,dx1,dy1,east_c1,
     $           north_c1,east_u1,north_u1,east_v1,north_v1,rot1,
     $           t1,s1,rmean1,tclim1,sclim1,tb1,sb1,ub1,vb1)

      return
      end
C
