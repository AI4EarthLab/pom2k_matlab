function[dx,dy,cor,pdens... 
    east_c,north_c,east_e,north_e,east_u,north_u,east_v,north_v,...
    h,art,aru,arv,fsm,dum,dvm,...
    tsurf,ssurf,tb,sb,tclim,sclim,ub,uab,elb,etb,dt,...
    aam2d,rho,rmean,rfe,rfw,rfn,rfs,...
    uabw,uabe,ele,elw,tbe,tbw,sbe,sbw,tbn,tbs,sbn,sbs,rot,els,eln,vabs,vabn,ubw,ube,vbs,vbn] = file2ic(dx,dy,cor,pdens,hhi,...
    east_c,north_c,east_e,north_e,east_u,north_u,east_v,north_v,...
    h,art,aru,arv,fsm,dum,dvm,...
    tsurf,ssurf,tb,sb,tclim,sclim,ub,uab,elb,etb,dt,...
    aam2d,rho,rmean,rfe,rfw,rfn,rfs,...
    uabw,uabe,ele,elw,tbe,tbw,sbe,sbw,tbn,tbs,sbn,sbs,...
    e_atmos,aam,im,jm,kb,imm1,jmm1,kbm1,slmax,zz,tbias,sbias,grav,rhoref,rot,els,eln,vabs,vabn,ubw,ube,vbs,vbn)
% **********************************************************************
% *                                                                    *
% * FUNCTION    :  Sets up my own problem.                             *
% *                                                                    *
% * This example read IC from IC.dat file, generated by GRID.f in      *
% * GRID-DATA directory. Only minimal number of fields are read,       *
% * while others are calculated here.                                  *
% *                                                                    *
% **********************************************************************
%
field = '';
rad=0.01745329;
re=6371.E3;
fprintf('(/,'' Read grid and initial conditions '',/');
%
%--- 1D ---
fid = fopen('data.in','r');
fscanf(fid,'%s',field);
fprintf('%s',filed);
for k=1:kb
    fscanf('%f',z(k));
end

fscanf(fid,'%s',field);
fprintf('%s',filed);
for k=1:kb
    fscanf(fid,'%f',zz(k));
end

fscanf(fid,'%s',field);
fprintf('%s',filed);
for k=1:kb
    fscanf(fid,'%f',dz(k));
end

fscanf(fid,'%s',field);
fprintf('%s',filed);
for k=1:kb
    fscanf(fid,'%f',dzz(k));
end


%--- 2D ---
fscanf(fid,'%s',field);
fprintf('%s',filed);
for i=1:im
    for j=1:jm
        fscanf(fid,'%f',east_e(i,j));
    end
end

fscanf(fid,'%s',field);
fprintf('%s',filed);
for i=1:im
    for j=1:jm
        fscanf(fid,'%f',north_e(i,j));
    end
end


fscanf(fid,'%s',field);
fprintf('%s',filed);
for i=1:im
    for j=1:jm
        fscanf(fid,'%f',h(i,j));
    end
end

fscanf(fid,'%s',field);
fprintf('%s',filed);
for i=1:im
    for j=1:jm
        fscanf(fid,'%f',h(i,j));
    end
end

%--- 3D ---

fscanf(fid,'%s',field);
fprintf('%s',filed);
for i=1:im
    for j=1:jm
        for k=1:kb
            fscanf(fid,'%f',t(i,j,k));
        end
    end
end

fscanf(fid,'%s',field);
fprintf('%s',filed);
for i=1:im
    for j=1:jm
        for k=1:kb
            fscanf(fid,'%f',s(i,j,k));
        end
    end
end

fscanf(fid,'%s',field);
fprintf('%s',filed);
for i=1:im
    for j=1:jm
        for k=1:kb
            fscanf(fid,'%f',rmean(i,j,k));
        end
    end
end



%--- Constant wind stress read here
% (for time dep. read in loop 9000 & interpolate in time)

fscanf(fid,'%s',field);
fprintf('%s',filed);
for i=1:im
    for j=1:jm
        scanf(fid,'%f',wusurf(i,j));
    end
end


fscanf(fid,'%s',field);
fprintf('%s',filed);
for i=1:im
    for j=1:jm
        scanf(fid,'%f',wvsurf(i,j));
    end
end

%% WAD Zhaowei 2017/11/10 move code from lat 
% lyo:_20080415:Move "calc. Coriolis etc" through "call areas_masks"
%      from below (after call dens) to here; otherwise, fsm will not
%      be defined but is used in subroutine dens. (This is a pom2k_bug).

% --- calc. Curiolis Parameter
%
for j=1:jm
    for i=1:im
        cor(i,j)=2.*7.29E-5*sin(north_e(i,j)*rad);
        aam2d(i,j)=aam(i,j,1);
        elb(i,j)=0.;
        etb(i,j)=0.;
        dt(i,j)=h(i,j);
    end
end
%
for j=1:jm
    for i=2:im-1
        dx(i,j)=0.5*rad*re*sqrt(((east_e(i+1,j)-east_e(i-1,j))...
            *cos(north_e(i,j)*rad))^2+(north_e(i+1,j)-north_e(i-1,j))^2);
    end
    dx(1,j)=dx(2,j);
    dx(im,j)=dx(im-1,j);
end
%
for i=1:im
    for j=2:jm-1
        dy(i,j)=0.5*rad*re*sqrt(((east_e(i,j+1)-east_e(i,j-1))...
            *cos(north_e(i,j)*rad))^2+(north_e(i,j+1)-north_e(i,j-1))^2);
    end
    dy(i,1)=dy(i,2);
    dy(i,jm)=dy(i,jm-1);
end
%
%     Calculate areas and masks:
%
[art,aru,arv,fsm,dum,dvm]=areas_masks(art,aru,arv,fsm,dum,dvm,...
    im,jm,dx,dy,h);
%
%
% --- calc. surface & lateral BC from climatology
%
for j=1:jm
    for i=1:im
        tsurf(i,j)=t(i,j,1);
        ssurf(i,j)=s(i,j,1);
        for k=1:kb
            tclim(i,j,k)=t(i,j,k);
            sclim(i,j,k)=s(i,j,k);
        end
    end
end
%
%                    --- EAST & WEST BCs ---
for j=1:jm
    ele(j)=0.;
    elw(j)=0.;
    % --- other vel. BCs (fixed in time) can be specified here
    uabe(j)=0.;
    uabw(j)=0.;
    for k=1:kb
        ubw(j,k)=0.;
        ube(j,k)=0.;
        tbw(j,k)=tclim(1,j,k);
        sbw(j,k)=sclim(1,j,k);
        tbe(j,k)=tclim(im,j,k);
        sbe(j,k)=sclim(im,j,k);
    end
end
%                    --- NORTH & SOUTH BCs ---
for i=1:im
    els(i)=0.;
    eln(i)=0.;
    vabs(i)=0.;
    vabn(i)=0.;
    for k=1:kb
        vbs(i,k)=0.;
        vbn(i,k)=0.;
        tbs(i,k)=tclim(i,1,k);
        sbs(i,k)=sclim(i,1,k);
        tbn(i,k)=tclim(i,jm,k);
        sbn(i,k)=sclim(i,jm,k);
    end
end
%
%     Set initial conditions:
%
tb = t;
sb = s;
ub = zeros(im,jm,kb);
vb=zeros(im,jm,kb);
% % WAD Zhaowei 2017/11/9-----------------------------------------------!
% lyo:!wad: Set up pdens before 1st call dens; used also in profq:      !
  pdenst=grav*rhoref*max(h(:,:)-hhi,0.e0))*1.e-5;
      do k=1:kbm1
         pdens(:,:,k)=-zz(k)*pdenst ;
      end

[sb,tb,rho]=dens(si,ti,rhoo,pdens, ...
    im,jm,kbm1,tbias,sbias,grav,rhoref,zz,h,fsm);

%
% --- the following grids are needed only for netcdf plotting
%
%     Corner of cell points:
%
for j=2:jm
    for i=2:im
        east_c(i,j)=(east_e(i,j)+east_e(i-1,j)...
            +east_e(i,j-1)+east_e(i-1,j-1))/4.e0;
        north_c(i,j)=(north_e(i,j)+north_e(i-1,j)...
            +north_e(i,j-1)+north_e(i-1,j-1))/4.e0;
    end
end
%
%
%     Extrapolate ends (approx.):
%
for i=2:im
    east_c(i,1)=2.*east_c(i,2)-east_c(i,3);
    north_c(i,1)=2.*north_c(i,2)-north_c(i,3);
end
east_c(1,1)=2.*east_c(2,1)-east_c(3,1);
%
for j=2:jm
    east_c(1,j)=2.*east_c(2,j)-east_c(3,j);
    north_c(1,j)=2.*north_c(2,j)-north_c(3,j);
end
north_c(1,1)=2.*north_c(1,2)-north_c(1,3);
%
%     u-points:
%
for j=1:jm-1
    for i=1:im
        east_u(i,j)=(east_c(i,j)+east_c(i,j+1))/2.e0;
        north_u(i,j)=(north_c(i,j)+north_c(i,j+1))/2.e0;
    end
end
%
%     Extrapolate ends:
%
for i=1:im
    east_u(i,jm)=(east_c(i,jm)*3.e0-east_c(i,jm-1))/2.e0;
    north_u(i,jm)=(north_c(i,jm)*3.e0-north_c(i,jm-1))/2.e0;
end
%
%     v-points:
%
for j=1:jm
    for i=1:im-1
        east_v(i,j)=(east_c(i,j)+east_c(i+1,j))/2.e0;
        north_v(i,j)=(north_c(i,j)+north_c(i+1,j))/2.e0;
    end
end
%
%     Extrapolate ends:
%
for j=1:jm
    east_v(im,j)=(east_c(im,j)*3.e0-east_c(im-1,j))/2.e0;
    north_v(im,j)=(north_c(im,j)*3.e0-north_c(im-1,j))/2.e0;
end
%
%     rot is the angle (radians, anticlockwise) of the i-axis relative
%     to east, averaged to a cell centre: (only needed for CDF plotting)
%
for j=1:jm
    for i=1:im-1
        rot(i,j)=0.;
        dlat=north_e(i+1,j)-north_e(i,j);
        dlon= east_e(i+1,j)- east_e(i,j);
        if(dlon~=0.)
            rot(i,j)=atan(dlat/dlon);
        end
    end
    rot(im,j)=rot(im-1,j);
end
%
%     Set lateral boundary conditions, for use in subroutine bcond
%     set all=0 for closed BCs.
%     Values=0 for vel BC only, =1 is combination of vel+elev.
rfe=0.e0;
rfw=0.e0;
rfn=0.e0;
rfs=0.e0;
%
return
end
